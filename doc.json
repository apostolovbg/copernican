{
  "projectName": "Copernican Suite",
  "version": "1.1.0 (Stable Release with Numba)",
  "lastUpdated": "2025-06-08",
  "description": "A Python-based framework for modularly testing and comparing cosmological models against observational data. This version features a stable, sequential workflow, enhanced diagnostics and plotting, and is now equipped with Numba-accelerated functions for high-performance fitting of complex models, ensuring numerical consistency with standard methods.",
  "goals": [
    "To provide a robust and extensible platform for fitting cosmological models to observational data.",
    "To compare alternative cosmological models against the standard LambdaCDM model using consistent statistical measures.",
    "To ensure consistent parameter handling when testing a model across different datasets (e.g., using SNe-fitted parameters for BAO analysis).",
    "To support various data formats through a modular data loading system.",
    "To allow easy and fast integration of new cosmological models via a standardized plugin architecture, with support for optional performance acceleration."
  ],
  "architecture": {
    "overview": "The suite is designed with a primary project directory containing all core scripts and model plugins. All outputs (logs, plots, CSVs) are saved into a dedicated 'output' subdirectory. The architecture is modular to facilitate easy extension and maintenance.",
    "coreModules": [
      {
        "name": "copernican.py",
        "role": "The main orchestrator script. It handles user interaction, dynamically loads model plugins, manages the sequential workflow, and directs all file outputs to the 'output/' subdirectory."
      },
      {
        "name": "data_loaders.py",
        "role": "Manages the loading and initial parsing of various observational datasets through a registered parser system."
      },
      {
        "name": "cosmo_engine.py",
        "role": "Contains the core physics and statistical logic. This includes chi-squared functions, the SNe parameter fitting algorithm, and a high-performance function dispatcher to select between standard and Numba-accelerated model calculations."
      },
      {
        "name": "output_manager.py",
        "role": "Handles all forms of output: logging, generating comparative plots with enhanced visuals (e.g., binned residual averages), and saving results to CSV files."
      },
      {
        "name": "Model Plugins (*.py) & Definitions (*.md)",
        "role": "A two-file system for each model. A Markdown (.md) file defines the theory and parameters, while a Python (.py) file contains the computational implementation."
      }
    ]
  },
  "workflowOverview": [
    "**1. Initialization & Configuration:** `copernican.py` starts, creates an 'output/' directory if one does not exist, and initializes logging.",
    "**2. User Input:** The user is prompted to specify the alternative model plugin file, the SNe Ia data file, and the BAO data file.",
    "**3. SNe Ia Fitting:** For both LambdaCDM and the specified alternative model, `cosmo_engine.fit_sne_parameters` is called. The engine's dispatcher checks for and prioritizes Numba-accelerated functions (e.g., `distance_modulus_model_numba`) to find the best-fit cosmological parameters.",
    "**4. BAO Analysis (Post-SNe Fit):** The SNe-fitted parameters for each model are used to calculate the model's BAO observable predictions (`DV/rs`, `DM/rs`, etc.) and the corresponding chi-squared value.",
    "**5. Output Generation:** `output_manager.py` is called to generate and save all comparative plots (Hubble Diagram, BAO observables) and summary CSV files into the 'output/' subdirectory."
  ],
  "pluginDevelopment": {
    "introduction": "One of the suite's primary goals is extensibility. Researchers can easily test new cosmological theories by creating a model definition file and a corresponding implementation.",
    "pluginInterfaceSpecification": {
      "interfaceName": "Copernican Suite Model Plugin",
      "version": "1.2",
      "description": "A model is now defined by a two-file system: a Markdown (.md) file for the theoretical and parametric definition, and a Python (.py) file for the implementation. This separates the human-readable theory from the computational code.",
      "fileConvention": {
        "summary": "Each new model requires two files with matching base names (e.g., `my_theory.md` and `my_theory.py`) located in the main project directory.",
        "modelDefinitionFile": {
          "format": "Markdown (.md)",
          "purpose": "Provides the human-readable theory and the machine-parsable parameter definitions. This is the source of truth for the model's metadata.",
          "structure": "Must contain a YAML front matter block and a 'Quantitative Model Specification' section with a parameter table. See usmf2.md for a template."
        },
        "modelPluginFile": {
          "format": "Python (.py)",
          "purpose": "Contains the functions that perform the cosmological calculations. Its metadata block (PARAMETER_NAMES, etc.) should be generated from the .md file's table.",
          "structure": "Must contain the required metadata block and functions as specified below."
        }
      },
      "requiredModuleComponents": {
        "metadataBlock (in .py)": {
          "description": "A set of global variables at the top of the Python file that define the model's identity and parameters for the fitter. This block should be consistent with the table in the corresponding .md file.",
          "attributes": ["MODEL_NAME", "PARAMETER_NAMES", "INITIAL_GUESSES", "PARAMETER_BOUNDS", "MODEL_EQUATIONS_LATEX_SN / _BAO (Optional)"]
        },
        "functionsBlock (in .py)": {
          "description": "A set of functions that calculate cosmological observables, accepting `z_array` and `*cosmo_params` as arguments.",
          "functions": ["distance_modulus_model", "get_luminosity_distance_Mpc", "get_comoving_distance_Mpc", "get_Hz_per_Mpc", "get_sound_horizon_rs_Mpc"]
        },
        "optionalPerformanceBlock (in .py)": {
          "description": "To accelerate fitting, you can provide alternative versions of the distance modulus function in the Python file. The engine will automatically detect and use the highest-performance version available.",
          "functionNames": ["distance_modulus_model_numba", "distance_modulus_model_opencl # For future GPU implementation"]
        }
      }
    }
  },
  "futureExpansionGuidelines": {
    "summary": "While the Numba-based CPU acceleration is now stable and effective, the next major architectural goal is to develop a fork of the suite that leverages GPU acceleration for even greater performance gains with highly complex models.",
    "MCMC_Integration": "The `fit_sne_parameters` function in `cosmo_engine.py` could be refactored to support other optimization backends, such as MCMC samplers (e.g., `emcee`, `dynesty`), for more robust parameter space exploration.",
    "GPU_Acceleration": "A key future direction is a new branch of the suite using GPU-native frameworks. This would require replacing SciPy's CPU-bound solvers (like `quad` and `brentq`) with custom, parallel-aware functions written in a GPU-compatible framework (e.g., PyTorch, JAX, or Numba's CUDA/ROCm features). The dispatcher in `cosmo_engine.py` already contains a placeholder to detect an OpenCL function, providing a clear path for this upgrade."
  }
}